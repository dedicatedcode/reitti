<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title th:text="${memory.title} + ' - Reitti'">Memory - Reitti</title>
    <link rel="icon" th:href="@{/img/logo.svg}">
    <link rel="stylesheet" th:href="@{/css/main.css}" href="../../static/css/main.css">
    <link rel="stylesheet" th:href="@{/css/lineicons.css}" href="../../static/css/lineicons.css">
    <link rel="stylesheet" href="/css/leaflet.css">
    <script src="/js/htmx.min.js"></script>
    <script src="/js/leaflet.js"></script>
    <script src="/js/leaflet.geodesic.2.7.2.js"></script>
    <script src="/js/TileLayer.Grayscale.js"></script>
    <script src="/js/raw-location-loader.js"></script>
</head>
<body class="memories-page">
<div class="settings-container">
    <div class="settings-content-area">
        <div class="memory-header" th:fragment="memory-header">
            <div class="action-bar">
                <button type="button" 
                        class="btn btn-secondary"
                        th:attr="hx-get=@{/memories/{id}/edit(id=${memory.id})}"
                        hx-target=".memory-header"
                        hx-swap="innerHTML">Edit
                </button>
            </div>

            <div class="memory-header-section" th:if="${memory.headerType.name() == 'IMAGE' && memory.headerImageUrl != null}">
                <img th:src="${memory.headerImageUrl}" th:alt="${memory.title}" class="memory-header-image-large">
            </div>

            <div class="memory-header-section map-header-section" th:if="${memory.headerType.name() == 'MAP'}">
                <div id="memory-map" class="memory-map"></div>
            </div>

            <div class="memory-details">
                <h1 class="memory-date-range-large">
                    <span th:text="${memory.title}">Title</span>
                </h1>
                <p class="memory-description-large" th:if="${memory.description != null && !memory.description.isEmpty()}"
                   th:text="${memory.description}">Description</p>
                <p class="memory-date-range-large">
                    <i class="lni lni-calendar"></i>
                    <span th:text="${#temporals.format(memory.startDate, 'MMMM d, yyyy')}">Start Date</span>
                    <span th:if="${memory.startDate != memory.endDate}">
                        - <span th:text="${#temporals.format(memory.endDate, 'MMMM d, yyyy')}">End Date</span>
                    </span>
                </p>

            </div>
        </div>

        <div class="memory-blocks-container">
            <div class="blocks-header">
                <h2>Blocks</h2>
                <button type="button" 
                        class="btn btn-primary"
                        th:attr="hx-get=@{/memories/{id}/blocks/select-type(id=${memory.id})}"
                        hx-target=".blocks-add-area"
                        hx-swap="innerHTML">
                    <i class="lni lni-plus"></i> Add Block
                </button>
            </div>

            <div class="blocks-add-area"></div>

            <div th:if="${blocks.isEmpty()}" class="empty-blocks">
                <i class="lni lni-layers"></i>
                <p>No blocks yet. Add your first block to start building your memory.</p>
            </div>

            <div class="blocks-list" id="blocksList">
                <div th:each="block : ${blocks}" class="memory-block" th:attr="data-block-id=${block.id}, data-block-type=${block.blockType.name()}">
                    <div class="block-header">
                        <span class="block-type-badge" th:text="${block.blockType.name()}">BLOCK TYPE</span>
                        <div class="block-actions">
                            <button class="btn " th:onclick="'editBlock(' + ${block.id} + ')'"><i class="lni lni-pencil-1"></i></button>
                            <button type="button" 
                                    class="btn btn-danger"
                                    th:attr="hx-delete=@{/memories/{memoryId}/blocks/{blockId}(memoryId=${memory.id}, blockId=${block.id})}"
                                    hx-target="closest .memory-block"
                                    hx-swap="outerHTML"
                                    hx-confirm="Delete this block?">
                                <i class="lni lni-trash-3"></i>
                            </button>
                        </div>
                    </div>
                    <div class="block-content">
                        <div th:if="${block.blockType.name() == 'TEXT'}" class="text-block">
                            <h3>Text Block</h3>
                            <p>Content will be loaded here</p>
                        </div>
                        <div th:if="${block.blockType.name() == 'VISIT'}" class="visit-block">
                            <i class="lni lni-map-marker"></i>
                            <p>Visit block</p>
                        </div>
                        <div th:if="${block.blockType.name() == 'TRIP'}" class="trip-block">
                            <i class="lni lni-direction"></i>
                            <p>Trip block</p>
                        </div>
                        <div th:if="${block.blockType.name() == 'IMAGE_GALLERY'}" class="gallery-block">
                            <i class="lni lni-gallery"></i>
                            <p>Image gallery</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>


<script th:inline="javascript">
    (function () {
        const memory = /*[[${memory}]]*/ {};
        const rawLocationUrl = /*[[${rawLocationUrl}]]*/ '';
        let memoryMap = null;
        let rawLocationLoader = null;

        function initializeMemoryMap() {
            // Only initialize if header type is MAP and map container exists
            if (memory.headerType === 'MAP' && document.getElementById('memory-map')) {
                // Remove existing map if it exists
                if (memoryMap) {
                    memoryMap.remove();
                }

                memoryMap = L.map('memory-map', {
                    zoomControl: false,
                    attributionControl: false,
                    boxZoom: false,
                    doubleClickZoom: false,
                    dragging: false,
                    keyboard: false,
                    scrollWheelZoom: false,
                    tap: false,
                    touchZoom: false
                }).setView([51.505, -0.09], 13);

                L.tileLayer.grayscale('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 19,
                    attribution: 'Â© OpenStreetMap contributors'
                }).addTo(memoryMap);

                // Initialize raw location loader for the memory
                if (rawLocationUrl) {
                    rawLocationLoader = new RawLocationLoader(memoryMap, {});
                    const userConfigs = [{
                        url: rawLocationUrl,
                        color: '#f1ba63',
                        avatarUrl: null,
                        avatarFallback: null,
                        displayName: 'Memory Location Data'
                    }];
                    rawLocationLoader.init(userConfigs);

                    // Load location data for the memory date range without bounds filtering
                    rawLocationLoader.loadForDateRange(
                        memory.startDate,
                        memory.endDate,
                        false, // autoUpdateMode
                        false  // withBounds - don't filter by current map bounds
                    );
                }
            }
        }

        // Initialize map on page load
        initializeMemoryMap();

        // Listen for htmx events to reinitialize map when header is updated
        document.body.addEventListener('htmx:afterSwap', function(event) {
            if (event.detail.target.classList.contains('memory-header')) {
                // Small delay to ensure DOM is updated
                setTimeout(initializeMemoryMap, 100);
            }
        });

    })();
</script>
</body>
</html>
