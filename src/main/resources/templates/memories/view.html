<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title th:text="${memory.title} + ' - Reitti'">Memory - Reitti</title>
    <link rel="icon" th:href="@{/img/logo.svg}">
    <link rel="stylesheet" th:href="@{/css/main.css}" href="../../static/css/main.css">
    <link rel="stylesheet" th:href="@{/css/lineicons.css}" href="../../static/css/lineicons.css">
    <link rel="stylesheet" href="/css/leaflet.css">
    <script src="/js/htmx.min.js"></script>
    <script src="/js/leaflet.js"></script>
    <script src="/js/leaflet.geodesic.2.7.2.js"></script>
    <script src="/js/TileLayer.Grayscale.js"></script>
    <script src="/js/raw-location-loader.js"></script>
    <script src="/js/HumanizeDuration.js"></script>
</head>
<body class="memories-page">
<div class="settings-container">
    <div class="settings-content-area">
        <div class="memory-header" th:fragment="memory-header">
            <div class="action-bar">
                <a  class="btn btn-secondary"
                        th:href="@{/memories}"
                        th:text="#{memory.view.back}">back
                </a>
                <button type="button" 
                        class="btn btn-secondary"
                        th:attr="hx-get=@{/memories/{id}/edit(id=${memory.id})}"
                        hx-target=".memory-header"
                        hx-swap="innerHTML"
                        hx-vals="js:{timezone: getUserTimezone()}"
                        th:text="#{memory.view.edit}">Edit
                </button>
                <button type="button" 
                        class="btn btn-primary"
                        th:attr="hx-post=@{/memories/{id}/recalculate(id=${memory.id})}"
                        hx-target="body"
                        hx-swap="innerHTML"
                        hx-confirm="Recalculate this memory? This will update all location data."
                        th:text="#{memory.view.recalculate}">Recalculate
                </button>
            </div>

            <div class="memory-header-section" th:if="${memory.headerType.name() == 'IMAGE' && memory.headerImageUrl != null}">
                <img th:src="${memory.headerImageUrl}" th:alt="${memory.title}" class="memory-header-image-large">
            </div>

            <div class="memory-header-section map-header-section" th:if="${memory.headerType.name() == 'MAP'}">
                <div id="memory-map" class="memory-map"></div>
            </div>

            <div class="memory-details">
                <h1 class="memory-date-range-large">
                    <span th:text="${memory.title}">Title</span>
                </h1>
                <p class="memory-description-large" th:if="${memory.description != null && !memory.description.isEmpty()}"
                   th:text="${memory.description}">Description</p>
                <p class="memory-date-range-large">
                    <i class="lni lni-calendar"></i>
                    <span th:text="${#temporals.format(memory.startDate, 'MMMM d, yyyy')}">Start Date</span>
                    <span th:if="${memory.startDate != memory.endDate}">
                        - <span th:text="${#temporals.format(memory.endDate, 'MMMM d, yyyy')}">End Date</span>
                    </span>
                </p>

            </div>
        </div>

        <div class="memory-blocks-container">
            <div class="blocks-header">
                <h2 th:text="#{memory.view.blocks.title}">Blocks</h2>
                <button type="button" 
                        class="btn btn-primary"
                        th:attr="hx-get=@{/memories/{id}/blocks/select-type(id=${memory.id})}"
                        hx-target=".blocks-add-area"
                        hx-swap="innerHTML">
                    <i class="lni lni-plus"></i> <span th:text="#{memory.view.add.block}">Add Block</span>
                </button>
            </div>

            <div class="blocks-add-area"></div>

            <div th:if="${blocks.isEmpty()}" class="empty-blocks">
                <i class="lni lni-layers"></i>
                <p th:text="#{memory.view.no.blocks}">No blocks yet. Add your first block to start building your memory.</p>
            </div>

            <div class="blocks-list" id="blocksList">
                <div th:each="block : ${blocks}" class="memory-block" th:attr="data-block-id=${block.blockId}, data-block-type=${block.type.name()}">
                    <div class="block-content">
                        <div th:if="${block.type.name() == 'TEXT'}" class="text-block">
                            <h3 th:text="${block.headline}">Text Block</h3>
                            <p th:text="${block.content}">Content will be loaded here</p>
                        </div>
                        <div th:if="${block.type.name() == 'VISIT'}" class="visit-block">
                            <div class="block-header">
                                <div class="visit-map" th:id="${'map_visit_' + block.blockId}"></div>
                                <script th:inline="javascript">
                                    (function() {
                                        const userSettings =  /*[[${userSettings}]]*/  {};
                                        const blockId =  /*[[${'map_visit_' + block.blockId}]]*/  'map_visit_99';
                                        const longitude =  /*[[${block.longitude}]]*/  53.551085;
                                        const latitude =   /*[[${block.latitude}]]*/  23.551085;
                                        const visitMap = L.map(blockId, {
                                            zoomControl: false,
                                            attributionControl: false,
                                            boxZoom: false,
                                            doubleClickZoom: false,
                                            dragging: false,
                                            keyboard: false,
                                            scrollWheelZoom: false,
                                            tap: false,
                                            touchZoom: false
                                        }).setView([latitude, longitude], 15);

                                        let tileLayer;
                                        if (userSettings.preferColoredMap) {
                                            tileLayer = L.tileLayer(userSettings.tiles.service, {
                                                maxZoom: 19,
                                                attribution: userSettings.tiles.attribution
                                            });
                                        } else {
                                            tileLayer = L.tileLayer.grayscale(userSettings.tiles.service, {
                                                maxZoom: 19,
                                                attribution: userSettings.tiles.attribution
                                            });
                                        }
                                        tileLayer.addTo(visitMap);
                                    })();
                                </script>
                                <h3 class="visit-title" th:text="${block.placeName != null ? block.placeName : 'Unknown Location'}">Place Name</h3>
                            </div>
                            <p th:if="${block.placeAddress != null}" class="visit-address" th:text="${block.placeAddress}">Address</p>
                            <div class="visit-details">
                                <div class="visit-time">
                                    <i class="lni lni-timer"></i>
                                    <span th:text="${#temporals.format(block.startTime, 'MMM d, yyyy HH:mm')}">Start Time</span>
                                    <span> - </span>
                                    <span th:text="${#temporals.format(block.endTime, 'HH:mm')}">End Time</span>
                                </div>
                                <div class="visit-duration" th:if="${block.durationSeconds != null}">
                                    <i class="lni lni-hourglass"></i>
                                    <span th:text="${block.durationSeconds >= 3600 ? #numbers.formatDecimal(block.durationSeconds / 3600.0, 1, 1) + ' hours' : #numbers.formatDecimal(block.durationSeconds / 60.0, 0, 0) + ' minutes'}">Duration</span>
                                </div>
                            </div>
                            <div class="visit-coordinates" th:if="${block.latitude != null && block.longitude != null}">
                                <small th:text="${#numbers.formatDecimal(block.latitude, 1, 6)} + ', ' + ${#numbers.formatDecimal(block.longitude, 1, 6)}">Coordinates</small>
                            </div>
                        </div>
                        <div th:if="${block.type.name() == 'TRIP'}" class="trip-block">
                            <div class="trip-header">
                                <i class="lni lni-direction"></i>
                                <h3>Trip</h3>
                            </div>
                            <div class="trip-route">
                                <span class="trip-location">
                                    <i class="lni lni-map-marker"></i>
                                    <span th:text="${block.startPlaceName != null ? block.startPlaceName : 'Start Location'}">Start</span>
                                </span>
                                <span class="trip-arrow">→</span>
                                <span class="trip-location">
                                    <i class="lni lni-map-marker"></i>
                                    <span th:text="${block.endPlaceName != null ? block.endPlaceName : 'End Location'}">End</span>
                                </span>
                            </div>
                            <div class="trip-details">
                                <div class="trip-time">
                                    <i class="lni lni-timer"></i>
                                    <span th:text="${#temporals.format(block.startTime, 'MMM d, yyyy HH:mm')}">Start Time</span>
                                    <span> - </span>
                                    <span th:text="${#temporals.format(block.endTime, 'HH:mm')}">End Time</span>
                                </div>
                                <div class="trip-duration" th:if="${block.durationSeconds != null}">
                                    <i class="lni lni-hourglass"></i>
                                    <span th:text="${block.durationSeconds >= 3600 ? #numbers.formatDecimal(block.durationSeconds / 3600.0, 1, 1) + ' hours' : #numbers.formatDecimal(block.durationSeconds / 60.0, 0, 0) + ' minutes'}">Duration</span>
                                </div>
                                <div class="trip-distance" th:if="${block.estimatedDistanceMeters != null}">
                                    <i class="lni lni-ruler"></i>
                                    <span th:text="${#numbers.formatDecimal(block.estimatedDistanceMeters / 1000.0, 1, 1)} + ' km'">Distance</span>
                                </div>
                                <div class="trip-mode" th:if="${block.transportModeInferred != null}">
                                    <i class="lni lni-car"></i>
                                    <span th:text="${block.transportModeInferred}">Transport Mode</span>
                                </div>
                            </div>
                        </div>
                        <div th:if="${block.type.name() == 'IMAGE_GALLERY'}" class="gallery-block">
                            <i class="lni lni-gallery"></i>
                            <p th:text="#{memory.view.block.gallery.content}">Image gallery</p>
                        </div>
                        <div th:if="${block.type.name() == 'CLUSTER'}" class="cluster-block">
                            <div class="block-header">
                                <i class="lni lni-layers"></i>
                                <h3 th:text="${block.title}">Cluster Title</h3>
                            </div>
                            <p th:if="${block.description != null}" class="cluster-description" th:text="${block.description}">Description</p>
                            <div class="cluster-map" th:id="${'map_cluster_' + block.blockId}"></div>
                            <script th:inline="javascript">
                                (function() {
                                    const userSettings =  /*[[${userSettings}]]*/  {};
                                    const blockId =  /*[[${'map_cluster_' + block.blockId}]]*/  'map_cluster_99';
                                    const trips =  /*[[${block.trips}]]*/  [];
                                    const rawLocationUrl =  /*[[${block.rawLocationPointsUrl}]]*/  '';
                                    const combinedStartTime =  /*[[${block.combinedStartTime}]]*/  null;

                                    // Initialize map
                                    const clusterMap = L.map(blockId, {
                                        attributionControl: false,
                                    }).setView([50,50], 19);

                                    let tileLayer;
                                    if (userSettings.preferColoredMap) {
                                        tileLayer = L.tileLayer(userSettings.tiles.service, {
                                            maxZoom: 19,
                                            attribution: userSettings.tiles.attribution
                                        });
                                    } else {
                                        tileLayer = L.tileLayer.grayscale(userSettings.tiles.service, {
                                            maxZoom: 19,
                                            attribution: userSettings.tiles.attribution
                                        });
                                    }
                                    tileLayer.addTo(clusterMap);

                                    let clusterRawLocationLoader = new RawLocationLoader(clusterMap, userSettings);

                                    // Load raw location data for the cluster's time range
                                    if (rawLocationUrl) {
                                        const userConfigs = [{
                                            respectBounds: false,
                                            url: rawLocationUrl,
                                            color: '#f1ba63',
                                            avatarUrl: null,
                                            avatarFallback: null,
                                            displayName: 'Cluster Path'
                                        }];
                                        clusterRawLocationLoader.init(userConfigs);
                                        clusterRawLocationLoader.loadForDateRange(false, false);
                                    }

                                    // Define SVG icons for markers
                                    const startIcon = L.divIcon({
                                        className: 'custom-marker',
                                        html: '<svg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><circle cx="10" cy="10" r="8" fill="green" stroke="white" stroke-width="2"/><path d="M10 5 L15 10 L10 15 L5 10 Z" fill="white"/></svg>',
                                        iconSize: [40, 40],
                                        iconAnchor: [10, 10]
                                    });

                                    const stopIcon = L.divIcon({
                                        className: 'custom-marker',
                                        html: '<svg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><circle cx="10" cy="10" r="8" fill="red" stroke="white" stroke-width="2"/><rect x="8" y="8" width="4" height="4" fill="white"/></svg>',
                                        iconSize: [40, 40],
                                        iconAnchor: [10, 10]
                                    });

                                    const endIcon = L.divIcon({
                                        className: 'custom-marker',
                                        html: '<svg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><circle cx="10" cy="10" r="8" fill="blue" stroke="white" stroke-width="2"/><circle cx="10" cy="10" r="4" fill="white"/></svg>',
                                        iconSize: [40, 40],
                                        iconAnchor: [10, 10]
                                    });

                                    // Add markers for start, stops, and end
                                    let bounds = [];
                                    if (trips.length > 0) {
                                        // Start marker
                                        const startTrip = trips[0];
                                        if (startTrip.startVisit && startTrip.startVisit.place) {
                                            const startLat = startTrip.startVisit.place.latitudeCentroid;
                                            const startLon = startTrip.startVisit.place.longitudeCentroid;
                                            const startName = startTrip.startVisit.place.name;
                                            const startTimeFormatted = combinedStartTime ? new Date(combinedStartTime).toLocaleTimeString() : 'unknown';
                                            L.marker([startLat, startLon], {icon: startIcon}).addTo(clusterMap).bindPopup('Start: ' + startName + '<br>Departed at: ' + startTimeFormatted);
                                            bounds.push([startLat, startLon]);
                                        }

                                        // Intermediate stops (end of each trip except last)
                                        for (let i = 0; i < trips.length - 1; i++) {
                                            const trip = trips[i];
                                            if (trip.endVisit && trip.endVisit.place) {
                                                const lat = trip.endVisit.place.latitudeCentroid;
                                                const lon = trip.endVisit.place.longitudeCentroid;
                                                const name = trip.endVisit.place.name;
                                                const arrivedAfter = combinedStartTime && trip.endTime ? humanizeDuration((new Date(trip.endTime) - new Date(combinedStartTime)),{units: ["h", "m"], round: true}) : 'unknown';
                                                L.marker([lat, lon], {icon: stopIcon}).addTo(clusterMap).bindPopup('Stop: ' + name + '<br>Arrived after: ' + arrivedAfter);
                                                bounds.push([lat, lon]);
                                            }
                                        }

                                        // End marker
                                        const endTrip = trips[trips.length - 1];
                                        if (endTrip.endVisit && endTrip.endVisit.place) {
                                            const endLat = endTrip.endVisit.place.latitudeCentroid;
                                            const endLon = endTrip.endVisit.place.longitudeCentroid;
                                            const endName = endTrip.endVisit.place.name;
                                            const arrivedAfter = combinedStartTime && endTrip.endTime ? humanizeDuration((new Date(endTrip.endTime) - new Date(combinedStartTime)),{units: ["h", "m"], round: true}) : 'unknown';
                                            L.marker([endLat, endLon], {icon: endIcon}).addTo(clusterMap).bindPopup('End: ' + endName + '<br>Arrived after: ' + arrivedAfter);
                                            bounds.push([endLat, endLon]);
                                        }
                                    }

                                    // Fit map to bounds if markers exist
                                    if (bounds.length > 0) {
                                        clusterMap.fitBounds(bounds, {padding: [10, 10]});
                                    } else {
                                        clusterMap.setView([51.505, -0.09], 13);
                                    }
                                })();
                            </script>
                            <div class="cluster-summary" th:if="${block.combinedStartTime != null && block.combinedEndTime != null}">
                                <div class="cluster-time">
                                    <i class="lni lni-timer"></i>
                                    <span th:text="${#temporals.format(block.combinedStartTime, 'MMM d, yyyy HH:mm')}">Start Time</span>
                                    <span> - </span>
                                    <span th:text="${#temporals.format(block.combinedEndTime, 'HH:mm')}">End Time</span>
                                </div>
                                <div class="cluster-duration" th:if="${block.combinedDurationSeconds != null}">
                                    <i class="lni lni-hourglass"></i>
                                    <span th:text="${block.combinedDurationSeconds >= 3600 ? #numbers.formatDecimal(block.combinedDurationSeconds / 3600.0, 1, 1) + ' hours' : #numbers.formatDecimal(block.combinedDurationSeconds / 60.0, 0, 0) + ' minutes'}">Total Duration</span>
                                </div>
                            </div>
                            <div class="cluster-trips" th:if="${!block.trips.isEmpty()}">
                                <h4>Trips in this Journey:</h4>
                                <ul>
                                    <li th:each="trip : ${block.trips}" class="trip-item">
                                        <span th:text="${trip.startVisit != null && trip.startVisit.place != null ? trip.startVisit.place.name : 'Start'}">Start</span>
                                        <span> → </span>
                                        <span th:text="${trip.endVisit != null && trip.endVisit.place != null ? trip.endVisit.place.name : 'End'}">End</span>
                                        <th:block th:with="elapsedSeconds=${T(java.time.Duration).between(block.combinedStartTime, trip.startTime).getSeconds()}">
                                            <span th:if="${elapsedSeconds != null}" th:text="' (arrived after ' + ${elapsedSeconds >= 3600 ? #numbers.formatDecimal(elapsedSeconds / 3600.0, 1, 1) + ' hours' : #numbers.formatDecimal(elapsedSeconds / 60.0, 0, 0) + ' minutes'} + ')'">Duration</span>
                                        </th:block>
                                    </li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="block-actions">
                        <button class="btn " th:onclick="'editBlock(' + ${block.blockId} + ')'"><i class="lni lni-pencil-1"></i></button>
                        <button type="button"
                                class="btn btn-danger"
                                th:attr="hx-delete=@{/memories/{memoryId}/blocks/{blockId}(memoryId=${memory.id}, blockId=${block.blockId})}"
                                hx-target="closest .memory-block"
                                hx-swap="outerHTML"
                                hx-confirm="Delete this block?">
                            <i class="lni lni-trash-3"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>


<script th:inline="javascript">
    // User settings for timezone handling
    window.userSettings = /*[[${userSettings}]]*/ {};

    function getUserTimezone() {
        if (window.userSettings.timeZoneOverride) {
            return window.userSettings.timeZoneOverride;
        } else {
            return Intl.DateTimeFormat().resolvedOptions().timeZone;
        }
    }

    function humanizeDuration(seconds) {
        if (!seconds || seconds <= 0) return 'unknown';
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        if (hours > 0) {
            return hours + 'h ' + minutes + 'm';
        } else {
            return minutes + 'm';
        }
    }

    const memory = /*[[${memory}]]*/ {};
    const rawLocationUrl = /*[[${rawLocationUrl}]]*/ '';
    let rawLocationLoader = null;
    let memoryMap = null;


    function initializeMemoryMap() {
        // Only initialize if header type is MAP and map container exists
        if (memory.headerType === 'MAP' && document.getElementById('memory-map')) {
            if (memoryMap && typeof memoryMap.getContainer === 'function') {
                memoryMap.remove();
            }

            memoryMap = L.map('memory-map', {
                zoomControl: false,
                attributionControl: false,
                boxZoom: false,
                doubleClickZoom: false,
                dragging: false,
                keyboard: false,
                scrollWheelZoom: false,
                tap: false,
                touchZoom: false
            }).setView([51.505, -0.09], 13);

            L.tileLayer.grayscale('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '© OpenStreetMap contributors'
            }).addTo(memoryMap);
            if (rawLocationLoader === null) {
                rawLocationLoader = new RawLocationLoader(memoryMap, window.userSettings);
            }
            // Initialize raw location loader for the memory
            if (rawLocationUrl && rawLocationLoader !== null) {
                const userConfigs = [{
                    url: rawLocationUrl,
                    color: '#f1ba63',
                    avatarUrl: null,
                    avatarFallback: null,
                    displayName: 'Memory Location Data'
                }];
                rawLocationLoader.init(userConfigs);

                // Load location data for the memory date range without bounds filtering
                rawLocationLoader.loadForDateRange(
                    memory.startDate,
                    memory.endDate,
                    false, // autoUpdateMode
                    false  // withBounds - don't filter by current map bounds
                );
            }
        }
    }

    // Initialize map on page load
    initializeMemoryMap();

    // Listen for htmx events to reinitialize map when header is updated
    document.body.addEventListener('htmx:afterSwap', function (event) {
        if (event.detail.target.classList.contains('memory-header')) {
            initializeMemoryMap()

            if (rawLocationUrl) {
                if (rawLocationLoader === null) {
                    rawLocationLoader = new RawLocationLoader(memoryMap, {});
                }
                const userConfigs = [{
                    url: rawLocationUrl,
                    color: '#f1ba63',
                    avatarUrl: null,
                    avatarFallback: null,
                    displayName: 'Memory Location Data'
                }];
                rawLocationLoader.init(userConfigs);
                rawLocationLoader.reloadForCurrentView(false);
            }
        }
    });
</script>
</body>
</html>
