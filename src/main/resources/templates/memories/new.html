<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title th:text="#{memory.new.page.title}">New Memory - Reitti</title>
    <link rel="icon" th:href="@{/img/logo.svg}">
    <link rel="stylesheet" th:href="@{/css/main.css}" href="../../static/css/main.css">
    <link rel="stylesheet" th:href="@{/css/lineicons.css}" href="../../static/css/lineicons.css">
    <link rel="stylesheet" th:href="@{/css/gallery-block.css}" href="../../static/css/gallery-block.css">
    <link rel="stylesheet" th:href="@{/css/photo-client.css}" href="../../static/css/photo-client.css">
    <link rel="stylesheet" href="/css/leaflet.css">
    <style>
        /* DateTime Picker Styles */
        .datetime-picker {
            position: relative;
            display: flex;
            align-items: center;
        }

        .datetime-picker .native-input {
            flex: 1;
            margin-right: 8px;
        }

        .picker-trigger {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }

        .picker-trigger:hover {
            background: #0056b3;
        }

        .picker-popup {
            position: absolute;
            top: 100%;
            left: 0;
            z-index: 1000;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            margin-top: 4px;
            min-width: 600px;
        }

        .picker-container {
            display: flex;
            padding: 16px;
            gap: 16px;
        }

        .calendar-section {
            flex: 2;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .calendar-header button {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .calendar-header button:hover {
            background: #f0f0f0;
        }

        .month-year {
            font-weight: bold;
            font-size: 16px;
        }

        .weekdays {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 4px;
            margin-bottom: 8px;
        }

        .weekday {
            text-align: center;
            font-weight: bold;
            font-size: 12px;
            color: #666;
            padding: 4px;
        }

        .days-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 2px;
        }

        .day {
            background: none;
            border: none;
            padding: 8px;
            text-align: center;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
        }

        .day:hover {
            background: #e3f2fd;
        }

        .day.selected {
            background: #007bff;
            color: white;
        }

        .day.other-month {
            color: #ccc;
        }

        .day.disabled {
            color: #ccc;
            cursor: not-allowed;
        }

        .year-scroll, .time-scroll {
            flex: 1;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 4px;
        }

        .year-list, .time-list {
            padding: 8px 0;
        }

        .year-item, .time-item {
            display: block;
            width: 100%;
            background: none;
            border: none;
            padding: 8px 16px;
            text-align: left;
            cursor: pointer;
            font-size: 14px;
        }

        .year-item:hover, .time-item:hover {
            background: #f0f0f0;
        }

        .year-item.selected, .time-item.selected {
            background: #007bff;
            color: white;
        }

        /* Scrollbar styling */
        .year-scroll::-webkit-scrollbar, .time-scroll::-webkit-scrollbar {
            width: 6px;
        }

        .year-scroll::-webkit-scrollbar-track, .time-scroll::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .year-scroll::-webkit-scrollbar-thumb, .time-scroll::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }

        .year-scroll::-webkit-scrollbar-thumb:hover, .time-scroll::-webkit-scrollbar-thumb:hover {
            background: #a1a1a1;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .picker-popup {
                min-width: 90vw;
                left: 50%;
                transform: translateX(-50%);
            }

            .picker-container {
                flex-direction: column;
                gap: 12px;
            }

            .year-scroll, .time-scroll {
                max-height: 200px;
            }
        }
    </style>
    <script src="/js/htmx.min.js"></script>
    <script src="/js/leaflet.js"></script>
    <script src="/js/leaflet.geodesic.2.7.2.js"></script>
    <script src="/js/TileLayer.Grayscale.js"></script>
    <script src="/js/raw-location-loader.js"></script>
    <script src="/js/HumanizeDuration.js"></script>
    <script src="/js/photo-client.js"></script>
</head>
<body class="memories-page">
<div class="settings-container">
    <div th:fragment="new-memory" class="settings-content-area">
        <div th:if="${error}" class="alert alert-error">
            <i class="lni lni-warning"></i>
            <span th:text="${error}">Error message</span>
        </div>
        <form th:attr="hx-post=@{/memories}" class="memory-form" hx-indicator="#memory-processing-overlay" hx-swap="outerHTML" hx-target="closest .settings-content-area" hx-vals='js:{"timezone": getUserTimezone()}' onsubmit="return validateDates()">
            <div class="form-group">
                <label for="title" th:text="#{memory.form.title.label}">Title *</label>
                <input type="text" id="title" name="title" required class="form-control" th:placeholder="#{memory.form.title.placeholder}" th:value="${title}">
                <input type="hidden" name="year" th:value="${year}">
            </div>

            <div class="form-group">
                <label for="description" th:text="#{memory.form.description.label}">Description</label>
                <textarea id="description" name="description" class="form-control" rows="4" th:placeholder="#{memory.form.description.placeholder}" th:text="${description}"></textarea>
            </div>

            <div class="form-row">
                <div class="form-group">
                    <label for="startDate" th:text="#{memory.form.start.date.label}">Start Date *</label>
                    <div class="datetime-picker" id="startDatePicker">
                        <input type="datetime-local" id="startDate" name="startDate" required class="native-input form-control"
                               th:value="${startDate}">
                        <button type="button" class="picker-trigger">ðŸ“…</button>
                        <div class="picker-popup" style="display: none;">
                            <div class="picker-container">
                                <div class="calendar-section">
                                    <div class="calendar-header">
                                        <button type="button" class="prev-month">â€¹</button>
                                        <span class="month-year"></span>
                                        <button type="button" class="next-month">â€º</button>
                                    </div>
                                    <div class="weekdays"></div>
                                    <div class="days-grid"></div>
                                </div>
                                <div class="year-scroll">
                                    <div class="year-list"></div>
                                </div>
                                <div class="time-scroll">
                                    <div class="time-list"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label for="endDate" th:text="#{memory.form.end.date.label}">End Date *</label>
                    <div class="datetime-picker" id="endDatePicker">
                        <input type="datetime-local" id="endDate" name="endDate" required class="native-input form-control"
                               th:value="${endDate}">
                        <button type="button" class="picker-trigger">ðŸ“…</button>
                        <div class="picker-popup" style="display: none;">
                            <div class="picker-container">
                                <div class="calendar-section">
                                    <div class="calendar-header">
                                        <button type="button" class="prev-month">â€¹</button>
                                        <span class="month-year"></span>
                                        <button type="button" class="next-month">â€º</button>
                                    </div>
                                    <div class="weekdays"></div>
                                    <div class="days-grid"></div>
                                </div>
                                <div class="year-scroll">
                                    <div class="year-list"></div>
                                </div>
                                <div class="time-scroll">
                                    <div class="time-list"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="dateError" class="alert alert-error" style="display: none;">
                <i class="lni lni-warning"></i>
                <span id="dateErrorText"></span>
            </div>

            <div class="form-actions">
                <button th:if="${year != 'all'}" th:attr="hx-get=@{/memories/year/{year}(year=${year})}"
                        hx-target=".memories-overview" hx-swap="outerHTML" hx-vals="js:{timezone: getUserTimezone()}" class="btn btn-primary" th:text="#{memory.form.cancel}">Cancel</button>
                <button th:if="${year == 'all'}" th:attr="hx-get=@{/memories/all}"
                        hx-target=".memories-overview" hx-swap="outerHTML" hx-vals="js:{timezone: getUserTimezone()}" class="btn btn-primary" th:text="#{memory.form.cancel}">Cancel</button>
                <button type="submit" class="btn btn-primary"
                        hx-disabled-elt="this">
                    <span th:text="#{memory.form.create}">Create Memory</span>
                </button>
            </div>
        </form>
        <script th:inline="javascript">
            // User settings from server
            window.userSettings = /*[[${userSettings}]]*/ {};

            function getUserTimezone() {
                if (window.userSettings.timezoneOverride) {
                    return window.userSettings.timezoneOverride;
                } else {
                    return Intl.DateTimeFormat().resolvedOptions().timeZone;
                }
            }

            function validateDates() {
                const startDate = document.getElementById('startDate').value;
                const endDate = document.getElementById('endDate').value;
                const errorDiv = document.getElementById('dateError');
                const errorText = document.getElementById('dateErrorText');

                if (!startDate || !endDate) {
                    errorText.textContent = /*[[#{memory.form.date.error.empty}]]*/ 'Dates cannot be empty';
                    errorDiv.style.display = 'block';
                    return false;
                }

                if (new Date(startDate) > new Date(endDate)) {
                    errorText.textContent = /*[[#{memory.form.date.error.end.before.start}]]*/ 'End date must be on or after start date';
                    errorDiv.style.display = 'block';
                    return false;
                }

                errorDiv.style.display = 'none';
                return true;
            }

            // DateTimePicker Class
            class DateTimePicker {
                constructor(element, options = {}) {
                    this.options = {
                        timeFormat: options.timeFormat || '24h',
                        minDate: options.minDate || null,
                        maxDate: options.maxDate || null,
                        onValidate: options.onValidate || null,
                        locale: options.locale || navigator.language
                    };

                    this.element = element;
                    this.nativeInput = element.querySelector('.native-input');
                    this.triggerButton = element.querySelector('.picker-trigger');
                    this.popup = element.querySelector('.picker-popup');
                    this.calendarSection = element.querySelector('.calendar-section');
                    this.yearScroll = element.querySelector('.year-scroll');
                    this.timeScroll = element.querySelector('.time-scroll');

                    this.currentDate = new Date();
                    this.selectedDate = null;

                    this.init();
                }

                init() {
                    this.setupEventListeners();
                    this.renderCalendar();
                    this.renderYearList();
                    this.renderTimeList();
                    this.updateFromNativeInput();
                }

                setupEventListeners() {
                    this.triggerButton.addEventListener('click', (e) => {
                        e.preventDefault();
                        this.togglePopup();
                    });

                    this.nativeInput.addEventListener('change', () => {
                        this.updateFromNativeInput();
                        if (this.options.onValidate) {
                            this.options.onValidate(this.getValue());
                        }
                    });

                    // Calendar navigation
                    this.element.querySelector('.prev-month').addEventListener('click', () => {
                        this.currentDate.setMonth(this.currentDate.getMonth() - 1);
                        this.renderCalendar();
                    });

                    this.element.querySelector('.next-month').addEventListener('click', () => {
                        this.currentDate.setMonth(this.currentDate.getMonth() + 1);
                        this.renderCalendar();
                    });

                    // Close popup when clicking outside
                    document.addEventListener('click', (e) => {
                        if (!this.element.contains(e.target)) {
                            this.closePopup();
                        }
                    });
                }

                renderCalendar() {
                    const monthYear = this.element.querySelector('.month-year');
                    const weekdays = this.element.querySelector('.weekdays');
                    const daysGrid = this.element.querySelector('.days-grid');

                    // Update month/year header
                    monthYear.textContent = this.currentDate.toLocaleDateString(this.options.locale, {
                        month: 'long',
                        year: 'numeric'
                    });

                    // Render weekdays
                    weekdays.innerHTML = '';
                    const weekdayNames = [];
                    for (let i = 0; i < 7; i++) {
                        const date = new Date(2023, 0, i + 1); // Start from Sunday
                        weekdayNames.push(date.toLocaleDateString(this.options.locale, { weekday: 'short' }));
                    }
                    weekdayNames.forEach(day => {
                        const dayElement = document.createElement('div');
                        dayElement.className = 'weekday';
                        dayElement.textContent = day;
                        weekdays.appendChild(dayElement);
                    });

                    // Render days grid
                    daysGrid.innerHTML = '';
                    const firstDay = new Date(this.currentDate.getFullYear(), this.currentDate.getMonth(), 1);
                    const lastDay = new Date(this.currentDate.getFullYear(), this.currentDate.getMonth() + 1, 0);
                    const startDate = new Date(firstDay);
                    startDate.setDate(startDate.getDate() - firstDay.getDay());

                    for (let i = 0; i < 42; i++) {
                        const date = new Date(startDate);
                        date.setDate(startDate.getDate() + i);

                        const dayElement = document.createElement('button');
                        dayElement.type = 'button';
                        dayElement.className = 'day';
                        dayElement.textContent = date.getDate();

                        if (date.getMonth() !== this.currentDate.getMonth()) {
                            dayElement.classList.add('other-month');
                        }

                        if (this.selectedDate && this.isSameDay(date, this.selectedDate)) {
                            dayElement.classList.add('selected');
                        }

                        if (this.isDateDisabled(date)) {
                            dayElement.disabled = true;
                            dayElement.classList.add('disabled');
                        }

                        dayElement.addEventListener('click', () => {
                            if (!this.isDateDisabled(date)) {
                                this.selectDate(date);
                            }
                        });

                        daysGrid.appendChild(dayElement);
                    }
                }

                renderYearList() {
                    const yearList = this.element.querySelector('.year-list');
                    yearList.innerHTML = '';

                    const currentYear = new Date().getFullYear();
                    const startYear = currentYear - 50;
                    const endYear = currentYear + 50;

                    for (let year = startYear; year <= endYear; year++) {
                        const yearElement = document.createElement('button');
                        yearElement.type = 'button';
                        yearElement.className = 'year-item';
                        yearElement.textContent = year;

                        if (year === this.currentDate.getFullYear()) {
                            yearElement.classList.add('selected');
                        }

                        yearElement.addEventListener('click', () => {
                            this.currentDate.setFullYear(year);
                            this.renderCalendar();
                            this.renderYearList();
                        });

                        yearList.appendChild(yearElement);
                    }
                }

                renderTimeList() {
                    const timeList = this.element.querySelector('.time-list');
                    timeList.innerHTML = '';

                    for (let hour = 0; hour < 24; hour++) {
                        for (let minute = 0; minute < 60; minute += 15) {
                            const timeElement = document.createElement('button');
                            timeElement.type = 'button';
                            timeElement.className = 'time-item';

                            const timeString = this.formatTime(hour, minute);
                            timeElement.textContent = timeString;
                            timeElement.dataset.hour = hour;
                            timeElement.dataset.minute = minute;

                            timeElement.addEventListener('click', () => {
                                this.selectTime(hour, minute);
                            });

                            timeList.appendChild(timeElement);
                        }
                    }
                }

                formatTime(hour, minute) {
                    if (this.options.timeFormat === '12h') {
                        const period = hour >= 12 ? 'PM' : 'AM';
                        const displayHour = hour === 0 ? 12 : hour > 12 ? hour - 12 : hour;
                        return `${displayHour}:${minute.toString().padStart(2, '0')} ${period}`;
                    } else {
                        return `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
                    }
                }

                selectDate(date) {
                    if (!this.selectedDate) {
                        this.selectedDate = new Date();
                    }
                    this.selectedDate.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
                    this.updateNativeInput();
                    this.renderCalendar();
                }

                selectTime(hour, minute) {
                    if (!this.selectedDate) {
                        this.selectedDate = new Date();
                    }
                    this.selectedDate.setHours(hour, minute, 0, 0);
                    this.updateNativeInput();
                    this.highlightSelectedTime();
                }

                highlightSelectedTime() {
                    this.element.querySelectorAll('.time-item').forEach(item => {
                        item.classList.remove('selected');
                        if (this.selectedDate &&
                            parseInt(item.dataset.hour) === this.selectedDate.getHours() &&
                            parseInt(item.dataset.minute) === this.selectedDate.getMinutes()) {
                            item.classList.add('selected');
                        }
                    });
                }

                updateNativeInput() {
                    if (this.selectedDate) {
                        const isoString = this.selectedDate.toISOString().slice(0, 16);
                        this.nativeInput.value = isoString;
                    }
                }

                updateFromNativeInput() {
                    if (this.nativeInput.value) {
                        this.selectedDate = new Date(this.nativeInput.value);
                        this.currentDate = new Date(this.selectedDate);
                        this.renderCalendar();
                        this.renderYearList();
                        this.highlightSelectedTime();
                    }
                }

                togglePopup() {
                    const isVisible = this.popup.style.display !== 'none';
                    if (isVisible) {
                        this.closePopup();
                    } else {
                        this.openPopup();
                    }
                }

                openPopup() {
                    this.popup.style.display = 'block';
                    if (this.selectedDate) {
                        this.scrollToSelectedYear();
                        this.scrollToSelectedTime();
                    }
                }

                closePopup() {
                    this.popup.style.display = 'none';
                }

                scrollToSelectedYear() {
                    const selectedYear = this.element.querySelector('.year-item.selected');
                    if (selectedYear) {
                        selectedYear.scrollIntoView({ block: 'center' });
                    }
                }

                scrollToSelectedTime() {
                    const selectedTime = this.element.querySelector('.time-item.selected');
                    if (selectedTime) {
                        selectedTime.scrollIntoView({ block: 'center' });
                    }
                }

                isSameDay(date1, date2) {
                    return date1.getFullYear() === date2.getFullYear() &&
                           date1.getMonth() === date2.getMonth() &&
                           date1.getDate() === date2.getDate();
                }

                isDateDisabled(date) {
                    if (this.options.minDate && date < this.options.minDate) {
                        return true;
                    }
                    if (this.options.maxDate && date > this.options.maxDate) {
                        return true;
                    }
                    return false;
                }

                getValue() {
                    return this.nativeInput.value;
                }

                setValue(value) {
                    this.nativeInput.value = value;
                    this.updateFromNativeInput();
                }
            }

            // Initialize datetime pickers when DOM is loaded
            document.addEventListener('DOMContentLoaded', function() {
                const startDatePicker = new DateTimePicker(document.getElementById('startDatePicker'), {
                    timeFormat: '24h',
                    onValidate: validateDates
                });

                const endDatePicker = new DateTimePicker(document.getElementById('endDatePicker'), {
                    timeFormat: '24h',
                    onValidate: validateDates
                });
            });
        </script>
    </div>
</div>

</body>
</html>
