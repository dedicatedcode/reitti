<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" xmlns:sec="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title th:text="#{page.title}">Reitti - Your Location Timeline</title>
    <link rel="icon" th:href="@{/img/logo.svg}">
    <link rel="apple-touch-icon" th:href="@{/img/logo.svg}">
    <link rel="shortcut icon" type="image/x-icon" th:href="@{/img/logo.svg}">
    <link rel="stylesheet" th:href="@{/css/leaflet.css}" href="/css/leaflet.css">
    <link rel="stylesheet" th:href="@{/css/date-picker.css}" href="/css/date-picker.css">
    <link rel="stylesheet" th:href="@{/css/main.css}" href="/css/main.css">
    <link rel="stylesheet" th:href="@{/css/lineicons.css}" href="/css/lineicons.css">
    <link rel="stylesheet" th:href="@{/css/photo-client.css}" href="/css/photo-client.css">
    <link rel="stylesheet" th:href="@{/css/inline-edit.css}" href="/css/inline-edit.css">
    <link rel="stylesheet" th:href="@{/css/avatar-marker.css}" href="/css/avatar-marker.css">
    <link th:if="${userSettings.customCssUrl}" rel="stylesheet" th:href="${userSettings.customCssUrl}">
    <script th:src="@{/js/HumanizeDuration.js}"></script>
    <script th:src="@{/js/date-picker-combined.js}"></script>
    <script th:src="@{/js/timeline-scroll-indicator.js}"></script>
    <script th:src="@{/js/photo-client.js}"></script>
    <script th:src="@{/js/raw-location-loader.js}"></script>
    <script th:src="@{/js/canvas-visit-renderer.js}"></script>
    <script th:src="@{/js/htmx.min.js}"></script>
    <script th:src="@{/js/leaflet.js}"></script>
    <script th:src="@{/js/TileLayer.Grayscale.js}"></script>
    <script th:src="@{/js/polygon-editor.js}"></script>
    <script th:src="@{/js/leaflet.geodesic.2.7.2.js}"></script>
    <script th:src="@{/js/leaflet.markercluster.js}"></script>
    <script th:src="@{/js/util.js}"></script>
</head>
<body>
<div id="message-container">
    <div id="sse-message"></div>
</div>
<div id="map"></div>

<!-- Auto-update overlay -->
<div id="auto-update-overlay" class="auto-update-overlay">
    <button sec:authorize="hasAnyRole('ROLE_ADMIN', 'ROLE_USER', 'ROLE_MAGIC_LINK_FULL_ACCESS')" class="overlay-button exit-button" onclick="disableAutoUpdate()" th:title="#{map.auto-update.disable.title}">
        <i class="lni lni-pause"></i>
    </button>
    <button class="overlay-button fullscreen-button" onclick="toggleFullscreen()" th:title="#{map.fullscreen.toggle.title}" title="Toggle Fullscreen">
        <i class="lni lni-arrow-all-direction"></i>
    </button>
    <div class="date" id="auto-update-date"></div>
    <div class="time" id="auto-update-time"></div>
</div>

<div class="navigation-container" th:replace="~{fragments/main-navigation :: main-navigation('index')}"></div>
<div class="timeline">
    <div class="timeline-container"
         th:hx-get="@{/timeline/content/range}"
         hx-trigger="dateChanged from:body"
         hx-vals="js:{startDate: getTimelineParams().startDate, endDate: getTimelineParams().endDate, timezone: getTimelineParams().timezone}"
         hx-indicator="#loading-indicator">
        <div id="loading-indicator" class="timeline-entry" th:text="#{timeline.loading}">Loading...</div>
    </div>
    <button type="button" class="timeline-toggle-btn" id="timeline-toggle-btn" onclick="toggleTimeline()" th:title="#{timeline.state.hide.title}" title="Hide Timeline">
        <i class="lni lni-exit"></i>
    </button>
</div>

<button type="button" class="datepicker-toggle-btn" id="datepicker-toggle-btn" onclick="toggleDatePicker()" th:title="#{datepicker.state.hide.title}" title="Hide Date Picker">
    <i class="lni lni-exit-down"></i>
</button>
<div id="date-picker-container">

</div>

<!-- Today FAB button -->
<button type="button" class="today-fab" id="today-fab" onclick="goToToday()" th:title="#{datepicker.today.title}" title="Go to Today" style="display: none;">
    <i class="lni lni-calendar-days"></i>
    <span th:text="#{datepicker.today}">Today</span>
</button>

<script th:inline="javascript">
    window.contextPath = /*[[@{/}]]*/ "/";
    window.contextPath = window.contextPath.replace(/\/$/, '');

    // Locale object for JavaScript
    window.locale = {
        today: /*[[#{datepicker.today}]]*/ 'Today',
        days: [
            /*[[#{datepicker.days.sun}]]*/ 'Sun',
            /*[[#{datepicker.days.mon}]]*/ 'Mon',
            /*[[#{datepicker.days.tue}]]*/ 'Tue',
            /*[[#{datepicker.days.wed}]]*/ 'Wed',
            /*[[#{datepicker.days.thu}]]*/ 'Thu',
            /*[[#{datepicker.days.fri}]]*/ 'Fri',
            /*[[#{datepicker.days.sat}]]*/ 'Sat'
        ],
        months: [
            /*[[#{datepicker.months.jan}]]*/ 'Jan',
            /*[[#{datepicker.months.feb}]]*/ 'Feb',
            /*[[#{datepicker.months.mar}]]*/ 'Mar',
            /*[[#{datepicker.months.apr}]]*/ 'Apr',
            /*[[#{datepicker.months.may}]]*/ 'May',
            /*[[#{datepicker.months.jun}]]*/ 'Jun',
            /*[[#{datepicker.months.jul}]]*/ 'Jul',
            /*[[#{datepicker.months.aug}]]*/ 'Aug',
            /*[[#{datepicker.months.sep}]]*/ 'Sep',
            /*[[#{datepicker.months.oct}]]*/ 'Oct',
            /*[[#{datepicker.months.nov}]]*/ 'Nov',
            /*[[#{datepicker.months.dec}]]*/ 'Dec'
        ],
        sse: {
            error: /*[[#{sse.error.connection-lost}]]*/ 'Connection to server lost! Will reconnect ...',
        },
        autoupdate: {
          latestLocation:  /*[[#{map.auto-update.latest-location}]]*/ 'Latest location',
          state: {
              enable: /*[[#{map.auto-update.enable.title}]]*/ 'Enter Auto-Update Mode',
              disable: /*[[#{map.auto-update.disable.title}]]*/ 'Leave Auto-Update Mode',
          }
        },
        datepicker: {
            state : {
                hide: /*[[#{datepicker.state.hide.title}]]*/ 'Hide Date Picker',
                show:  /*[[#{datepicker.state.show.title}]]*/ 'Show Date Picker'
            }
        },
        timeline: {
            state : {
                hide: /*[[#{timeline.state.hide.title}]]*/ 'Hide Timeline',
                show:  /*[[#{timeline.state.show.title}]]*/ 'Show Timeline'

            }
        }
    };

    window.userSettings = /*[[${userSettings}]]*/ {}

    const messagesDiv = document.getElementById('sse-message');
    let autoUpdateMode = false;
    let autoUpdateTimer = null;
    let autoUpdateTimeInterval = null;
    let eventSource = null;
    let reloadTimeoutId = null;
    let maxWaitTimeoutId = null;
    let pendingEvents = [];
    let firstEventTime = null;
    let reconnectTimeoutId = null;

    // Store current date range selection
    let currentDateRange = null;

    // Initialize the map
    const map = L.map('map', {zoomControl: false, attributionControl: false}).setView([window.userSettings.homeLatitude, window.userSettings.homeLongitude], 12);

    // Initialize raw location loader and canvas visit renderer
    let rawLocationLoader;
    let canvasVisitRenderer;

    /**
     * Retrieves the selected date based on the URL parameters or application settings.
     * If both 'startDate' and 'endDate' are present in the URL, it returns the 'startDate'.
     * If the UI mode is set to 'SHARED_LIVE_MODE_ONLY', it returns the current local date.
     * Otherwise, it uses the newest data from the user settings, or defaults to the current local date.
     *
     * This method should always return a valid **local** date in the format 'YYYY-MM-DD'.
     * @return {string} The selected date in the format 'YYYY-MM-DD'.
     */
    function getSelectedDate() {
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has('startDate') && urlParams.has('endDate')) {
            return urlParams.get('startDate');
        } else if (window.userSettings.uiMode === 'SHARED_LIVE_MODE_ONLY') {
            return getCurrentLocalDate();
        } else if (window.userSettings.newestData) {
            return getAsLocalDate(window.userSettings.newestData);
        } else {
            return getCurrentLocalDate();
        }
    }

    function getUserTimezone() {
        if (window.userSettings.timezoneOverride) {
            return window.userSettings.timezoneOverride;
        } else {
            return Intl.DateTimeFormat().resolvedOptions().timeZone;
        }
    }

    function getTimelineParams() {
        const timezone = getUserTimezone();
        if (currentDateRange && currentDateRange.startDate && currentDateRange.endDate) {
            // Range mode - use actual range
            return {
                startDate: currentDateRange.startDate,
                endDate: currentDateRange.endDate,
                timezone: timezone
            };
        } else {
            throw new Error('Invalid date range');
        }
    }


    function selectUser(userHeader) {
        // Remove active class from all user headers
        document.querySelectorAll('.user-header').forEach(header => {
            header.classList.remove('active');
        });

        // Add active class to clicked user header
        userHeader.classList.add('active');

        // Get the user ID from the clicked header
        const userId = userHeader.getAttribute('data-user-id');

        // Hide all user timeline sections
        document.querySelectorAll('.user-timeline-section').forEach(section => {
            section.classList.remove('active');
        });

        // Show the corresponding user timeline section
        const targetSection = document.querySelector(`.user-timeline-section[data-user-id="${userId}"]`);
        if (targetSection) {
            targetSection.classList.add('active');
        }
    }

    // Timeline visibility functions
    function toggleTimeline() {
        const body = document.body;
        const isHidden = body.classList.contains('timeline-hidden');
        
        if (isHidden) {
            body.classList.remove('timeline-hidden');
            localStorage.setItem('timelineHidden', 'false');
        } else {
            // Scroll timeline back to top before hiding to ensure navbar is accessible
            const timeline = document.querySelector('.timeline');
            if (timeline) {
                timeline.scrollTop = 0;
            }
            body.classList.add('timeline-hidden');
            localStorage.setItem('timelineHidden', 'true');
        }
        
        updateTimelineToggleButton();
    }
    
    function updateTimelineToggleButton() {
        const btn = document.getElementById('timeline-toggle-btn');
        const icon = btn.querySelector('i');
        const isHidden = document.body.classList.contains('timeline-hidden');
        
        if (isHidden) {
            icon.className = 'lni lni-enter';
            btn.title = window.locale.timeline.state.show;
        } else {
            icon.className = 'lni lni-exit';
            btn.title = window.locale.timeline.state.hide;
        }
    }
    
    // Restore timeline visibility state from localStorage
    function restoreTimelineState() {
        const timelineHidden = localStorage.getItem('timelineHidden');
        if (timelineHidden === 'true') {
            document.body.classList.add('timeline-hidden');
        }
        updateTimelineToggleButton();
    }
    
    // Date picker visibility functions
    function toggleDatePicker() {
        const body = document.body;
        const isHidden = body.classList.contains('datepicker-hidden');
        
        if (isHidden) {
            body.classList.remove('datepicker-hidden');
            localStorage.setItem('datepickerHidden', 'false');
        } else {
            body.classList.add('datepicker-hidden');
            localStorage.setItem('datepickerHidden', 'true');
        }
        
        updateDatePickerToggleButton();
    }
    
    function updateDatePickerToggleButton() {
        const btn = document.getElementById('datepicker-toggle-btn');
        const icon = btn.querySelector('i');
        const isHidden = document.body.classList.contains('datepicker-hidden');
        
        if (isHidden) {
            icon.className = 'lni lni-exit-up';
            btn.title = window.locale.datepicker.state.show;
        } else {
            icon.className = 'lni lni-enter-down';
            btn.title = window.locale.datepicker.state.hide;
        }

        // Update today FAB visibility when date picker visibility changes
        updateTodayFabVisibility();
    }
    
    // Restore date picker visibility state from localStorage
    function restoreDatePickerState() {
        const datepickerHidden = localStorage.getItem('datepickerHidden');
        if (datepickerHidden === 'true') {
            document.body.classList.add('datepicker-hidden');
        }
        updateDatePickerToggleButton();
    }

    function updateUrlWithDate(currentDateRange) {
        const url = new URL(window.location);
        url.searchParams.set('startDate', currentDateRange.startDate);
        url.searchParams.set('endDate', currentDateRange.endDate);
        url.searchParams.delete('date');
        window.history.pushState({}, '', url);
    }

    document.addEventListener('DOMContentLoaded', function () {
        // Restore timeline state on page load
        restoreTimelineState();
        // Restore date picker state on page load
        restoreDatePickerState();
        // Check if date is in URL parameters

        const tilesUrl = window.contextPath + window.userSettings.tiles.service;
        const tilesAttribution = window.userSettings.tiles.attribution;

        const tileLayer = window.userSettings.preferColoredMap ? L.tileLayer : L.tileLayer.grayscale;
        tileLayer(tilesUrl, {
            maxZoom: 19,
            attribution:  tilesAttribution
        }).addTo(map);
        L.control.attribution({position: 'topright'}).addAttribution(tilesAttribution)
            .addTo(map)

        // Initialize photo client
        const photoClient = new PhotoClient(map, window.userSettings.photoMode === 'ENABLED');
        
        // Initialize raw location loader
        rawLocationLoader = new RawLocationLoader(map, window.userSettings, {
            paddingTopLeft: [100,0],
            paddingBottomRight: [100, 300],
            zoomSnap: 0.1
        });

        // Initialize raw location loader with user configurations
        initializeRawLocationLoader();
        
        // Initialize canvas visit renderer with higher z-index to render above raw location data
        canvasVisitRenderer = new CanvasVisitRenderer(map);
        
        // Ensure visit renderer is above raw location data by setting higher z-index
        if (canvasVisitRenderer.canvasRenderer && canvasVisitRenderer.canvasRenderer.getPane()) {
            canvasVisitRenderer.canvasRenderer.getPane().style.zIndex = 450;
        }

        // Listen for map move/zoom events to update photo markers
        map.on('moveend zoomend', () => {
            photoClient.onMapMoveEnd();
        });

        function loadTimelineData(startDate, endDate) {
            if (startDate && endDate && startDate !== endDate) {
                // Range mode
                photoClient.updatePhotosForRange(startDate, endDate, getUserTimezone());
            } else {
                const date = startDate || getSelectedDate();
                photoClient.updatePhotosForRange(date, date, getUserTimezone());
            }
            
            // Load raw location data using the loader
            rawLocationLoader.loadForDateRange(autoUpdateMode, false);
        }

        // Function to initialize raw location loader with user configurations
        function initializeRawLocationLoader() {
            const userConfigs = [];
            const timelineContainers = document.querySelectorAll('.user-timeline-section');

            timelineContainers.forEach(container => {
                const config = {
                    respectBounds: true,
                    url: container.dataset.rawLocationPointsUrl,
                    color: container.dataset.baseColor,
                    avatarUrl: container.dataset.userAvatarUrl,
                    avatarFallback: container.dataset.avatarFallback,
                    displayName: container.dataset.displayName
                };
                userConfigs.push(config);
            });

            rawLocationLoader.init(userConfigs);
        }

        // Add HTMX event handlers for timeline updates
        document.body.addEventListener('htmx:afterSwap', function(event) {
            if (event.detail.target.classList.contains('timeline-container')) {
                // Re-initialize raw location loader with updated user configurations
                initializeRawLocationLoader();

                // Timeline content has been updated, update map markers
                const params = getTimelineParams();
                loadTimelineData(params.startDate, params.endDate);
                updateMapFromTimeline();
                // Initialize scroll indicator after timeline is updated
                if (window.timelineScrollIndicator) {
                    window.timelineScrollIndicator.cleanup();
                }
                window.timelineScrollIndicator = new TimelineScrollIndicator();
                window.timelineScrollIndicator.init();
                
                // Update edit place links with current URL
                updateEditPlaceLinks();
            }
        });
        // Function to update map markers from processed visits API
        function updateMapFromTimeline() {
            const bounds = L.latLngBounds();

            // Clear existing markers and paths (except tile layer)
            map.eachLayer(layer => {
                if (!layer._url) {
                    map.removeLayer(layer);
                }
            });

            const allVisits = [];
            
            // Get current map bounds for API request
            const mapBounds = map.getBounds();

            // Get user configurations for colors
            const userConfigs = new Map();
            const timelineUserSections = document.querySelectorAll('.user-timeline-section');
            
            timelineUserSections.forEach(container => {
                const userId = container.dataset.userId;
                const color = container.dataset.baseColor;
                userConfigs.set(userId, { color: color });
            });

            // Fetch processed visits for each user
            const fetchPromises = [];
            timelineUserSections.forEach(container => {
                const userId = container.dataset.userId;
                const baseUrl = container.dataset.processedVisitsUrl;
                
                if (!baseUrl) {
                    console.warn(`No processed visits URL found for user ${userId}`);
                    return;
                }
                
                const urlParams = new URLSearchParams({
                    minLat: mapBounds.getSouth(),
                    maxLat: mapBounds.getNorth(),
                    minLng: mapBounds.getWest(),
                    maxLng: mapBounds.getEast()
                });

                const fullUrl = baseUrl.includes('?') ? `${baseUrl}&${urlParams}` : `${baseUrl}?${urlParams}`;

                fetchPromises.push(
                    fetch(window.contextPath + fullUrl)
                        .then(response => response.json())
                        .then(data => ({ userId, data, color: userConfigs.get(userId)?.color }))
                        .catch(error => {
                            console.error(`Error fetching visits for user ${userId}:`, error);
                            return { userId, data: { places: [] }, color: userConfigs.get(userId)?.color };
                        })
                );
            });

            Promise.all(fetchPromises).then(results => {
                results.forEach(({ userId, data, color }) => {
                    if (data.places) {
                        data.places.forEach(placeSummary => {
                            const place = placeSummary.place;
                            if (place.lat && place.lng) {
                                const visitData = {
                                    lat: place.lat,
                                    lng: place.lng,
                                    totalDurationMs: placeSummary.totalDurationMs,
                                    visits: placeSummary.visits.map(v => ({ id: v.id })),
                                    place: {
                                        name: place.name || 'Unknown Place',
                                        address: place.address || '',
                                        polygon: place.polygon || null
                                    },
                                    color: color
                                };
                                
                                allVisits.push(visitData);
                                bounds.extend([place.lat, place.lng]);
                            }
                        });
                    }
                });

                // Update canvas renderer with all visits
                if (canvasVisitRenderer) {
                    canvasVisitRenderer.setVisits(allVisits);
                }
            }).catch(error => {
                console.error('Error fetching processed visits:', error);
                // Fallback to empty visits if API fails
                if (canvasVisitRenderer) {
                    canvasVisitRenderer.setVisits([]);
                }
            });

            return bounds;
        }

        // Handle clicks on timeline entries
        document.querySelector('.timeline-container').addEventListener('click', function (event) {
            const entry = event.target.closest('.timeline-entry');
            if (!entry) return;

            const editingElement = event.target.closest('.editing');
            if (editingElement || event.target.classList.contains('edit-icon')) {
                return;
            }
            // Check if this entry is already active (deselection case)
            const isCurrentlyActive = entry.classList.contains('active');
            
            // Remove active class from all entries
            document.querySelectorAll('.timeline-container .timeline-entry')
                .forEach(e => e.classList.remove('active'));
            const isTrip = entry.classList.contains('trip');

            if (isCurrentlyActive) {
                // Deselection: clear selected time range and zoom back to original bounds
                rawLocationLoader.clearSelectedTimeRange();
                if (window.originalBounds && window.originalBounds.isValid()) {
                    map.flyToBounds(window.originalBounds, rawLocationLoader.fitToBoundsConfig);
                }
            } else {
                // Selection: set time range and zoom to specific entry
                entry.classList.add('active');
                const newBounds = L.latLngBounds();

                const lat = parseFloat(entry.dataset.lat);
                const lng = parseFloat(entry.dataset.lng);
                const startTime = entry.dataset.start;
                const endTime = entry.dataset.end;

                // Set selected time range in raw location loader
                if (isTrip && startTime && endTime) {
                    rawLocationLoader.setSelectedTimeRange(startTime, endTime).then(selectedRangeBounds => {
                        if (selectedRangeBounds && selectedRangeBounds.isValid()) {
                            newBounds.extend(selectedRangeBounds);
                        }
                        
                        if (!isNaN(lat) && !isNaN(lng)) {
                            newBounds.extend([lat, lng]);
                        }

                        if (newBounds.isValid()) {
                            map.flyToBounds(newBounds, rawLocationLoader.fitToBoundsConfig);
                        }
                    });
                    return; // Exit early since we handle bounds in the promise
                }

                if (!isNaN(lat) && !isNaN(lng)) {
                    newBounds.extend([lat, lng]);
                }

                if (newBounds.isValid()) {
                    map.flyToBounds(newBounds, rawLocationLoader.fitToBoundsConfig);
                }
            }
        });

        window.horizontalDatePicker = new DatePicker('date-picker-container', {
            daysToShow: 14,
            prefetchDays: 25,
            allowRangeSelection: true,
            singleDateMode: true, // Enable single date mode with locking
            dateFormat: 'YYYY-MM-DD',
            locale: navigator.language,
            strings: {
                clickToUnlockDate: /*[[#{datepicker.click-to-unlock-date}]]*/ 'Click to unlock date',
                clickToLockDate: /*[[#{datepicker.click-to-lock-date}]]*/ 'Click to lock date',
                clickToClearSelection: /*[[#{datepicker.click-to-clear-selection}]]*/ 'Click to clear selection',
                clickToCreateRange: /*[[#{datepicker.click-to-create-range}]]*/ 'Click to create range',
                clickToExpandRangeBackward: /*[[#{datepicker.click-to-expand-range-backward}]]*/ 'Click to expand range backward',
                clickToExpandRangeForward: /*[[#{datepicker.click-to-expand-range-forward}]]*/ 'Click to expand range forward',
                clickToAdjustRangeStart: /*[[#{datepicker.click-to-adjust-range-start}]]*/ 'Click to adjust range start',
                clickToUnlockMonth: /*[[#{datepicker.click-to-unlock-month}]]*/ 'Click to unlock month',
                clickToLockMonth: /*[[#{datepicker.click-to-lock-month}]]*/ 'Click to lock month',
                clickToUnlockYear: /*[[#{datepicker.click-to-unlock-year}]]*/ 'Click to unlock year',
                clickToLockYear: /*[[#{datepicker.click-to-lock-year}]]*/ 'Click to lock year',
                select: /*[[#{datepicker.select}]]*/ 'Select',
                to: /*[[#{datepicker.to}]]*/ 'to'
            }
        });

        window.horizontalDatePicker.on('selectionChange', function (data) {
            console.log(`Selection changed`, data);
            const startDate = new Date(data.startDate + 'T00:00:00');
            let endDate;
            if (data.endDate) {
                endDate = new Date(data.endDate + 'T00:00:00');
            } else {
                switch (data.timeband) {
                    case 'day': endDate = startDate; break;
                    case 'month': endDate = new Date(startDate.getFullYear(), startDate.getMonth() + 1, 0); break;
                    case 'year': endDate = new Date(startDate.getFullYear(), 11, 31); break;
                }
            }
            currentDateRange = {
                startDate: window.horizontalDatePicker.formatDate(startDate),
                endDate: window.horizontalDatePicker.formatDate(endDate)
            };
            updateUrlWithDate(currentDateRange);
            // Trigger HTMX reload of timeline
            document.body.dispatchEvent(new CustomEvent('dateChanged'));

            // Check if today FAB should be shown
            updateTodayFabVisibility();
        });

        // Listen for date picker view changes to update FAB visibility
        window.horizontalDatePicker.on('viewChange', function() {
            updateTodayFabVisibility();
        });

        const startingDate = loadStartingDate();
        console.log(`Starting date: ${startingDate[0]} - ${startingDate[1]}`)
        window.horizontalDatePicker.setSelectedRange(startingDate[0], startingDate[1]);
    });

    function loadStartingDate() {
        const urlParams = new URLSearchParams(window.location.search);
        const newestData = window.userSettings.newestData;

        let startDate = urlParams.get('startDate');
        let endDate = urlParams.get('endDate');
        if (startDate) {
            // Validate date format (YYYY-MM-DD)
            if (!/^\d{4}-\d{2}-\d{2}$/.test(startDate)) {
                startDate = null;
            }
        }
        if (endDate) {
            // Validate date format (YYYY-MM-DD)
            if (!/^\d{4}-\d{2}-\d{2}$/.test(endDate)) {
                endDate = null;
            }
        }

        console.log('Starting date:', startDate, endDate);
        console.log('Newest data:', newestData);

        if (!startDate && !endDate) {
            if (window.userSettings.uiMode === 'SHARED_LIVE_MODE_ONLY') {
                return [getCurrentLocalDate(), ];
            } else if (window.userSettings.newestData) {
                return [getAsLocalDate(window.userSettings.newestData),];
            } else {
                return [getCurrentLocalDate(), ];
            }
        } else if (!startDate && endDate) {
            return [endDate, ];
        } else if (startDate && !endDate) {
            return [startDate, ];
        } else if (startDate === endDate) {
            return [startDate, ];
        }
        else {
            return [startDate, endDate];
        }
    }


    if (window.userSettings.uiMode === "SHARED_LIVE_MODE_ONLY") {
        toggleAutoUpdate();
    }
    function toggleAutoUpdate() {
        const btn = document.getElementById('auto-update-btn');
        const icon = btn ? btn.querySelector('i') : null;
        
        if (!autoUpdateMode) {
            document.body.classList.add('auto-update-mode');

            // Enable auto-update mode
            autoUpdateMode = true;

            if (btn) {
                icon.className = 'lni lni-pause';
                btn.title = window.locale.autoupdate.state.disable;
            }

            // Hide timeline and date picker smoothly
            hideUIElements();
            
            // Show auto-update overlay
            showAutoUpdateOverlay();
            
            // Update the date picker to today
            if (window.horizontalDatePicker) {
                window.horizontalDatePicker.setSelectedRange(getCurrentLocalDate(), null);
            }

            // Start the timer to check for date changes every 30 seconds
            startAutoUpdateTimer();

            // Connect to SSE with automatic reconnection
            connectSSE();

        } else {
            // Disable auto-update mode
            disableAutoUpdate();
        }
    }

    function disableAutoUpdate() {
        autoUpdateMode = false;
        
        // Clear the timer
        if (autoUpdateTimer) {
            clearInterval(autoUpdateTimer);
            autoUpdateTimer = null;
        }
        
        // Clear time update interval
        if (autoUpdateTimeInterval) {
            clearInterval(autoUpdateTimeInterval);
            autoUpdateTimeInterval = null;
        }
        
        // Clear any pending reload timeout
        if (reloadTimeoutId) {
            clearTimeout(reloadTimeoutId);
            reloadTimeoutId = null;
        }
        
        // Clear max wait timeout
        if (maxWaitTimeoutId) {
            clearTimeout(maxWaitTimeoutId);
            maxWaitTimeoutId = null;
        }
        
        // Clear pending events
        pendingEvents = [];
        firstEventTime = null;
        
        // Clear reconnect timeout
        if (reconnectTimeoutId) {
            clearTimeout(reconnectTimeoutId);
            reconnectTimeoutId = null;
        }
        
        if (eventSource) {
            eventSource.close();
            eventSource = null;
        }
        
        rawLocationLoader.removePulsatingMarkers();
        
        // Hide auto-update overlay
        hideAutoUpdateOverlay();
        
        // Show timeline and date picker again
        showUIElements();
        
        const btn = document.getElementById('auto-update-btn');
        const icon = btn.querySelector('i');
        icon.className = 'lni lni-play';
        btn.title = window.locale.autoupdate.state.enable;
        if (window.horizontalDatePicker) {
            window.horizontalDatePicker.setSelectedRange(getSelectedDate(), null);
        }

        document.body.classList.remove('auto-update-mode');

    }

    function startAutoUpdateTimer() {
        // Check every 30 seconds if we need to switch to today's date
        autoUpdateTimer = setInterval(() => {
            if (!autoUpdateMode) {
                return; // Exit if auto-update mode was disabled
            }
            
            // If the selected date is not today, switch to today
            if (!isSelectedDateToday()) {
                console.log('Auto-update: Switching to today\'s date');
                if (window.horizontalDatePicker) {
                    window.horizontalDatePicker.setSelectedRange(getCurrentLocalDate());
                }
            }
        }, 30000); // 30 seconds
    }

    function isSelectedDateToday() {
        const today = getCurrentLocalDate();
        const selectedDate = getSelectedDate();
        return selectedDate === today;
    }


    function scheduleTimelineReload(eventData) {
        // Add event to pending events
        pendingEvents.push(eventData);
        
        if (firstEventTime === null) {
            firstEventTime = Date.now();
            
            // Set maximum wait timeout (30 seconds from first event)
            maxWaitTimeoutId = setTimeout(() => {
                if (autoUpdateMode && pendingEvents.length > 0) {
                    console.log(`Auto-update: Reloading timeline data after max wait time (30s) with ${pendingEvents.length} accumulated events`);
                    executeTimelineReload();
                }
            }, 30000);
        }
        
        if (reloadTimeoutId) {
            clearTimeout(reloadTimeoutId);
        }
        
        reloadTimeoutId = setTimeout(() => {
            if (autoUpdateMode && pendingEvents.length > 0) {
                console.log(`Auto-update: Reloading timeline data after 5s settle time with ${pendingEvents.length} accumulated events`);
                executeTimelineReload();
            }
        }, 5000);
    }
    
    function executeTimelineReload() {
        // Clear all timeouts
        if (reloadTimeoutId) {
            clearTimeout(reloadTimeoutId);
            reloadTimeoutId = null;
        }
        if (maxWaitTimeoutId) {
            clearTimeout(maxWaitTimeoutId);
            maxWaitTimeoutId = null;
        }
        
        // Reload timeline
        document.body.dispatchEvent(new CustomEvent('dateChanged'));
        
        // Clear pending events and reset first event time
        pendingEvents = [];
        firstEventTime = null;
    }

    function connectSSE() {
        if (!autoUpdateMode) {
            return; // Don't connect if auto-update is disabled
        }

        console.log('Connecting to SSE...');
        eventSource = new EventSource('/events');

        eventSource.onopen = function() {
            console.log('SSE connection opened.');
            messagesDiv.innerHTML = ''; // Clear any error messages
            messagesDiv.classList.remove('active');
            
            // Clear any pending reconnect timeout since we're connected
            if (reconnectTimeoutId) {
                clearTimeout(reconnectTimeoutId);
                reconnectTimeoutId = null;
            }
        };

        eventSource.onerror = function(error) {
            console.error('EventSource failed:', error);
            messagesDiv.innerHTML = `<p><strong>${window.locale.sse.error}</strong></p>`;
            messagesDiv.classList.add('active');
            
            // Close the current connection
            if (eventSource) {
                eventSource.close();
                eventSource = null;
            }
            
            // Schedule reconnection after 5 seconds if still in auto-update mode
            if (autoUpdateMode && !reconnectTimeoutId) {
                console.log('Scheduling SSE reconnection in 5 seconds...');
                reconnectTimeoutId = setTimeout(() => {
                    reconnectTimeoutId = null;
                    connectSSE();
                }, 5000);
            }
        };

        eventSource.onmessage = function(event) {
            console.log('Received generic event:', event.data);
            
            // Clear error messages on successful message receipt (fallback for onopen)
            if (messagesDiv.classList.contains('active')) {
                messagesDiv.innerHTML = '';
                messagesDiv.classList.remove('active');
            }
            
            // Clear any pending reconnect timeout since we're receiving messages
            if (reconnectTimeoutId) {
                clearTimeout(reconnectTimeoutId);
                reconnectTimeoutId = null;
            }
            
            // Parse the event data
            try {
                const eventData = JSON.parse(event.data);
                
                // Check if the event has a date field and it matches today
                if (eventData.date) {
                    const today = getCurrentLocalDate(); // YYYY-MM-DD format
                    const eventDate = eventData.date;
                    
                    // If event date matches today and we're in auto-update mode, schedule reload
                    if (eventDate === today && autoUpdateMode) {
                        console.log('Auto-update: Scheduling timeline reload due to SSE event for today');
                        scheduleTimelineReload(eventData);
                    }
                }
            } catch (error) {
                console.warn('Could not parse SSE event data:', error);
            }
        };
    }

    function hideUIElements() {
        const timeline = document.querySelector('.timeline');
        const datePicker = document.getElementById('date-picker-container');

        timeline.classList.add('hidden');
        datePicker.classList.add('hidden');
    }

    function showUIElements() {
        const timeline = document.querySelector('.timeline');
        const datePicker = document.getElementById('date-picker-container');
        
        timeline.classList.remove('hidden');
        datePicker.classList.remove('hidden');
    }

    function showAutoUpdateOverlay() {
        const overlay = document.getElementById('auto-update-overlay');
        
        // Update initial time
        updateAutoUpdateTime();
        
        // Show overlay
        overlay.classList.add('visible');
        
        // Start updating time every second
        autoUpdateTimeInterval = setInterval(updateAutoUpdateTime, 1000);
    }

    function hideAutoUpdateOverlay() {
        const overlay = document.getElementById('auto-update-overlay');
        overlay.classList.remove('visible');
    }

    function updateAutoUpdateTime() {
        const now = new Date();
        const dateElement = document.getElementById('auto-update-date');
        const timeElement = document.getElementById('auto-update-time');
        
        // Use browser locale for date formatting
        const dateOptions = { 
            weekday: 'long', 
            year: 'numeric', 
            month: 'long', 
            day: 'numeric' 
        };
        const formattedDate = now.toLocaleDateString(navigator.language, dateOptions);
        
        // Use browser locale for time formatting
        const timeOptions = { 
            hour: '2-digit', 
            minute: '2-digit',
            hour12: false
        };
        const formattedTime = now.toLocaleTimeString(navigator.language, timeOptions);
        
        dateElement.textContent = formattedDate;
        timeElement.textContent = formattedTime;
    }

    function toggleFullscreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => {
                console.log(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else {
            document.exitFullscreen();
        }
    }

    function updateTodayFabVisibility() {
        const todayFab = document.getElementById('today-fab');
        if (!todayFab || !window.horizontalDatePicker) return;

        const today = getCurrentLocalDate();
        const isDatePickerHidden = document.body.classList.contains('datepicker-hidden');
        const isTodayVisible = window.horizontalDatePicker.isDateVisible(today);

        // Check if today is selected
        const selectedRange = window.horizontalDatePicker.getSelectedRange();
        const isTodaySelected = selectedRange && selectedRange.startDate === today &&
                               (!selectedRange.endDate || selectedRange.endDate === today);

        // Show FAB if date picker is visible and (today is not visible OR today is not selected)
        if (!isDatePickerHidden && (!isTodayVisible || !isTodaySelected)) {
            todayFab.style.display = 'flex';
        } else {
            todayFab.style.display = 'none';
        }
    }

    function goToToday() {
        if (window.horizontalDatePicker) {
            window.horizontalDatePicker.setSelectedRange(getCurrentLocalDate(), null);
        }
    }

    function updateEditPlaceLinks() {
        const currentUrl = window.location.href;
        const editLinks = document.querySelectorAll('.timeline-container .edit-icon[href*="/settings/places/"]');
        
        editLinks.forEach(link => {
            const href = link.getAttribute('href');
            const url = new URL(href, window.location.origin);
            url.searchParams.set('returnUrl', currentUrl);
            link.setAttribute('href', url.toString());
        });
    }
</script>
</body>
</html>
