<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reitti - Your Location Timeline</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="/css/date-picker.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/lineicons.css">
    <script src="/js/HumanizeDuration.js"></script>
    <script src="/js/horizontal-date-picker.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fraunces:ital,opsz,wght@0,9..144,100..900;1,9..144,100..900&display=swap"
          rel="stylesheet">
    <script src="https://unpkg.com/htmx.org@1.9.12"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
</head>
<body>
<div id="map"></div>

<!-- Settings Overlay -->
<div id="settings-overlay" class="settings-overlay">
    <div class="settings-content">
        <span class="close-settings">&times;</span>

        <div class="settings-nav">
            <div class="settings-nav-item active" data-target="api-tokens">API Tokens</div>
            <div class="settings-nav-item" data-target="user-management">User Management</div>
            <div class="settings-nav-item" data-target="places-management">Places</div>
            <div class="settings-nav-item" data-target="job-status">Job Status</div>
            <div class="settings-nav-item" data-target="file-upload">Import Data</div>
        </div>

        <!-- API Tokens Section -->
        <div id="api-tokens" class="settings-section active" hx-get="/settings/api-tokens-content"
             hx-trigger="revealed, every 30s">
            <div class="htmx-indicator">Loading tokens...</div>
        </div>

        <!-- User Management Section -->
        <div id="user-management" class="settings-section" hx-get="/settings/users-content" hx-trigger="revealed">
            <div class="htmx-indicator">Loading users...</div>
        </div>

        <!-- Places Management Section -->
        <div id="places-management" class="settings-section">
            <div class="htmx-indicator">Loading places...</div>
        </div>

        <script>
            // Function to initialize maps for place cards
            function initPlaceMaps() {
                document.querySelectorAll('.place-map').forEach(mapElement => {
                    const lat = parseFloat(mapElement.dataset.lat);
                    const lng = parseFloat(mapElement.dataset.lng);

                    if (!isNaN(lat) && !isNaN(lng)) {
                        const placeMap = L.map(mapElement, {
                            zoomControl: false,
                            attributionControl: false,
                            dragging: false,
                            scrollWheelZoom: false
                        }).setView([lat, lng], 14);

                        L.tileLayer('https://tiles.stadiamaps.com/tiles/alidade_smooth/{z}/{x}/{y}{r}.png', {
                            maxZoom: 20
                        }).addTo(placeMap);

                        L.circleMarker([lat, lng], {
                            radius: 8,
                            fillColor: '#4a89dc',
                            color: '#fff',
                            weight: 1,
                            opacity: 1,
                            fillOpacity: 0.8
                        }).addTo(placeMap);
                        placeMap.invalidateSize();
                    }
                });
            }

            document.body.addEventListener('htmx:afterSwap', function (event) {
                if (event.detail.target.id === 'places-management' ||
                    event.detail.target.closest('#places-management')) {
                    initPlaceMaps();
                }
            
                // Handle form resets after successful submission
                if (event.detail.target.id === 'user-management' || 
                    event.detail.target.closest('#user-management')) {
                    // Find and reset any forms in the user management section
                    const forms = event.detail.target.querySelectorAll('form');
                    forms.forEach(form => {
                        form.reset();
                    });
                }
            });
        </script>

        <!-- Job Status Section -->
        <div id="job-status" class="settings-section" hx-get="/settings/queue-stats-content"
             hx-trigger="revealed, every 5s">
            <div class="htmx-indicator">Loading queue stats...</div>
        </div>

        <!-- File Upload Section -->
        <div id="file-upload" class="settings-section">
            <div class="htmx-indicator">Loading file upload options...</div>
        </div>
    </div>
</div>


<div class="timeline">
    <span class="timeline-header">
        <a href="#" id="settings-button" class="nav-link"><i class="lni lni-gear-1" title="open settings ..."></i></a>
        <form th:action="@{/logout}" method="post" >
            <button type="submit" class="nav-link" style="font-size: 1.4rem;" title="logout"><i
                    class="lni lni-exit"></i>
            </button>
        </form>
    </span>

    <div class="timeline-container">
        <div id="loading-indicator" style="display: none;">Loading...</div>
        <!-- Timeline entries will be loaded here -->
    </div>
</div>

<!-- Horizontal date picker will be initialized here -->
<div id="horizontal-date-picker-container"></div>

<script>
    document.addEventListener('DOMContentLoaded', function () {
        // Settings overlay functionality
        const settingsButton = document.getElementById('settings-button');
        const settingsOverlay = document.getElementById('settings-overlay');
        const closeSettings = document.querySelector('.close-settings');

        // Open settings overlay
        settingsButton.addEventListener('click', function (e) {
            e.preventDefault();
            settingsOverlay.style.display = 'block';
            // HTMX will automatically load the content for other tabs
            
            // For places tab, we need to check if it's active and load content
            const placesTab = document.querySelector('.settings-nav-item[data-target="places-management"]');
            const placesSection = document.getElementById('places-management');
            
            if (placesSection.classList.contains('active')) {
                // If places tab is active, load its content
                placesSection.setAttribute('hx-get', '/settings/places-content?page=0');
                placesSection.setAttribute('hx-trigger', 'load');
                htmx.process(placesSection);
            }
        });

        // Close settings overlay
        closeSettings.addEventListener('click', function () {
            settingsOverlay.style.display = 'none';
        });

        // Close when clicking outside the content
        window.addEventListener('click', function (event) {
            if (event.target === settingsOverlay) {
                settingsOverlay.style.display = 'none';
            }
        });

        // Tab navigation in settings with htmx
        const navItems = document.querySelectorAll('.settings-nav-item');
        const sections = document.querySelectorAll('.settings-section');

        navItems.forEach(item => {
            item.addEventListener('click', function () {
                const target = this.getAttribute('data-target');

                // Update active nav item
                navItems.forEach(nav => nav.classList.remove('active'));
                this.classList.add('active');

                // Show target section
                sections.forEach(section => {
                    section.classList.remove('active');
                    if (section.id === target) {
                        section.classList.add('active');
                        
                        // If this is the places tab, load its content if not already loaded
                        if (target === 'places-management' && !section.hasAttribute('hx-triggered')) {
                            section.setAttribute('hx-get', '/settings/places-content?page=0');
                            section.setAttribute('hx-trigger', 'load');
                            section.setAttribute('hx-triggered', 'true');
                            htmx.process(section);
                        }
                        
                        // If this is the file upload tab, load its content if not already loaded
                        if (target === 'file-upload' && !section.hasAttribute('hx-triggered')) {
                            section.setAttribute('hx-get', '/settings/file-upload-content');
                            section.setAttribute('hx-trigger', 'load once');
                            section.setAttribute('hx-triggered', 'true');
                            htmx.process(section);
                        }
                    }
                });
            });
        });

        // Check if date is in URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        let initialDate;

        if (urlParams.has('date')) {
            initialDate = urlParams.get('date');
            // Validate date format (YYYY-MM-DD)
            if (!/^\d{4}-\d{2}-\d{2}$/.test(initialDate)) {
                initialDate = null;
            }
        }

        // Set date picker to URL date or today's date
        const today = new Date();
        const formattedDate = initialDate || today.toISOString().split('T')[0]; // YYYY-MM-DD format

        // Function to update URL with date parameter
        function updateUrlWithDate(date) {
            const url = new URL(window.location);
            url.searchParams.set('date', date);
            window.history.pushState({}, '', url);
        }

        // Initialize the map
        const map = L.map('map').setView([60.1699, 24.9384], 12); // Helsinki coordinates as default

        L.tileLayer('https://tiles.stadiamaps.com/tiles/alidade_smooth/{z}/{x}/{y}{r}.png', {
            maxZoom: 20,
            attribution: '&copy; <a href="https://stadiamaps.com/" target="_blank">Stadia Maps</a> &copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a> &copy; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a>',
        }).addTo(map);

        // Add scale control
        L.control.scale({
            imperial: false,
            metric: true
        }).addTo(map);

        // Function to load timeline data
        function loadTimelineData(date) {
            const loadingIndicator = document.getElementById('loading-indicator');
            loadingIndicator.style.display = 'block';

            // Fetch both timeline data and raw location points
            Promise.all([
                fetch(`/api/timeline?selectedDate=${date}`).then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                }),
                fetch(`/api/v1/raw-location-points?date=${date}`).then(response => {
                    if (!response.ok) {
                        // If endpoint doesn't exist or returns error, just return empty array
                        console.warn('Could not fetch raw location points');
                        return { points: [] };
                    }
                    return response.json();
                }).catch(error => {
                    console.warn('Error fetching raw location points:', error);
                    return { points: [] };
                })
            ])
            .then(([timelineData, rawPointsData]) => {
                updateTimeline(timelineData, rawPointsData);
                loadingIndicator.style.display = 'none';
            })
            .catch(error => {
                console.error('Error fetching data:', error);
                loadingIndicator.style.display = 'none';
            });
        }

        const selectedPath = L.polyline([], {
            color: '#ff984f',
            weight: 6,
            opacity: 1,
            lineJoin: 'round',
            lineCap: 'round'
        });

        // Create a polyline for raw location points
        const rawPointsPath = L.polyline([], {
            color: '#ecbc6f',  // Purple color for raw points
            weight: 6,
            opacity: 0.5,
            lineJoin: 'round',
            lineCap: 'round'
        });

        // Function to update the timeline with fetched data
        function updateTimeline(data, rawPointsData) {
            const timelineContainer = document.querySelector('.timeline-container');
            const loadingIndicator = document.getElementById('loading-indicator');
            timelineContainer.innerHTML = '';
            timelineContainer.appendChild(loadingIndicator);

            // Clear existing markers and paths
            map.eachLayer(layer => {
                if (!layer._url) {
                    map.removeLayer(layer);
                }
            });

            if (!data || !data.entries || data.entries.length === 0) {
                const noDataMsg = document.createElement('div');
                noDataMsg.className = 'timeline-entry';
                noDataMsg.textContent = 'No timeline data available for this date.';
                timelineContainer.appendChild(noDataMsg);
                return;
            }

            const bounds = L.latLngBounds();

            let hasValidCoords = false;

            // Create timeline entries
            data.entries.forEach(entry => {
                const entryElement = document.createElement('div');
                entryElement.className = `timeline-entry ${entry.type.toLowerCase()}`;
                entryElement.dataset.id = entry.id;

                // Set coordinates based on entry type
                if (entry.type === 'VISIT' && entry.place) {
                    entryElement.dataset.lat = entry.place.latitude;
                    entryElement.dataset.lng = entry.place.longitude;
                } else if (entry.type === 'TRIP') {
                    // For trips, use start place coordinates
                    if (entry.startPlace) {
                        entryElement.dataset.lat = entry.startPlace.latitude;
                        entryElement.dataset.lng = entry.startPlace.longitude;
                    }

                    // If trip has path data, add it
                    if (entry.path) {
                        entryElement.dataset.path = JSON.stringify(entry.path);
                    }
                }

                // Create time element
                const timeElement = document.createElement('div');
                timeElement.className = 'entry-time';
                const startTime = new Date(entry.startTime);
                const endTime = new Date(entry.endTime);
                
                // Get the selected date from the URL or use today
                const urlParams = new URLSearchParams(window.location.search);
                let selectedDateStr = urlParams.get('date');
                const selectedDate = selectedDateStr ? new Date(selectedDateStr) : new Date();
                selectedDate.setHours(0, 0, 0, 0); // Set to beginning of day
                
                // Format start time
                let startTimeStr = startTime.toLocaleTimeString([], {
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                });
                
                // If start time is not on the selected day, add day and month
                if (startTime.getDate() !== selectedDate.getDate() || 
                    startTime.getMonth() !== selectedDate.getMonth() || 
                    startTime.getFullYear() !== selectedDate.getFullYear()) {
                    startTimeStr = startTime.toLocaleDateString([], {
                        day: 'numeric',
                        month: 'short'
                    }) + ' ' + startTimeStr;
                }
                
                // Format end time
                let endTimeStr = endTime.toLocaleTimeString([], {
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                });
                
                // If end time is not on the selected day, add day and month
                if (endTime.getDate() !== selectedDate.getDate() || 
                    endTime.getMonth() !== selectedDate.getMonth() || 
                    endTime.getFullYear() !== selectedDate.getFullYear()) {
                    endTimeStr = endTime.toLocaleDateString([], {
                        day: 'numeric',
                        month: 'short'
                    }) + ' ' + endTimeStr;
                }
                
                timeElement.textContent = `${startTimeStr} - ${endTimeStr}`;

                // Calculate duration
                const durationMs = endTime - startTime;
                const durationText = humanizeDuration(durationMs, {units: ["h", "m"], round: true});

                const durationElement = document.createElement('span');
                durationElement.className = 'entry-duration';
                durationElement.textContent = `Duration: ${durationText}`;

                // Create description element
                const descElement = document.createElement('div');
                descElement.className = 'entry-description';

                if (entry.type === 'VISIT') {
                    descElement.textContent = entry.place ? entry.place.name || 'Unknown Place' : 'Unknown Place';
                } else if (entry.type === 'TRIP') {
                    descElement.textContent = `Trip`;
                    if (entry.distanceMeters) {
                        const distanceKm = (entry.distanceMeters / 1000).toFixed(1);
                        durationElement.textContent = `Distance: ${distanceKm} km `;
                    }

                    if (entry.transportMode) {
                        switch (entry.transportMode) {
                            case 'WALKING':
                                durationElement.textContent += entry.distanceMeters ? ' by foot' : ' walking';
                                break;
                            case 'CYCLING':
                                durationElement.textContent += entry.distanceMeters ? ' by bike' : ' cycling';
                                break;
                            case 'DRIVING':
                                durationElement.textContent += entry.distanceMeters ? ' by car' : ' driving';
                                break;
                        }

                    }
                }

                // Add elements to entry
                entryElement.appendChild(descElement);
                entryElement.appendChild(durationElement);
                entryElement.appendChild(timeElement);

                // Add entry to timeline
                timelineContainer.appendChild(entryElement);

                // Add markers for each entry with coordinates
                const lat = parseFloat(entryElement.dataset.lat);
                const lng = parseFloat(entryElement.dataset.lng);

                if (!isNaN(lat) && !isNaN(lng)) {
                    // Determine marker color based on entry type
                    const markerColor = entry.type === 'VISIT' ? '#4a89dc' : '#e67e22';

                    // Calculate radius based on duration for visits
                    let radius = 8;
                    if (entry.type === 'VISIT') {
                        const durationMs = new Date(entry.endTime) - new Date(entry.startTime);
                        const durationHours = durationMs / (1000 * 60 * 60);
                        // Scale radius based on duration: min 8, max 30
                        radius = Math.min(30, Math.max(8, 8 + (durationHours * 2)));
                    }
                    
                    // Create marker with custom icon
                    const marker = L.circleMarker([lat, lng], {
                        radius: radius,
                        fillColor: markerColor,
                        color: '#fff',
                        weight: 1,
                        opacity: 1,
                        fillOpacity: 0.8
                    }).addTo(map);

                    L.circle([lat, lng], {
                        color: '#4a89dc',
                        fillColor: '#6098e3',
                        fillOpacity: 0.1,
                        radius: radius * 5
                    }).addTo(map);

                    // Add popup with basic info including duration for visits
                    let popupContent = '';
                    if (entry.type === 'VISIT') {
                        const durationMs = new Date(entry.endTime) - new Date(entry.startTime);
                        const durationText = humanizeDuration(durationMs, {units: ["h", "m"], round: true});
                        popupContent = `<b>${entry.place?.name || 'Unknown Place'}</b><br>${timeElement.textContent}<br>Duration: ${durationText}`;
                    } else {
                        popupContent = `<b>Trip</b><br>${timeElement.textContent}`;
                    }

                    marker.bindPopup(popupContent);

                    // Extend bounds for map fitting
                    bounds.extend([lat, lng]);
                    hasValidCoords = true;
                }


                if (rawPointsData && rawPointsData.points && rawPointsData.points.length > 0) {
                    const rawPointsCoords = rawPointsData.points.map(point => [point.latitude, point.longitude]);

                    rawPointsPath.remove();
                    // Add the raw points polyline to the map
                    rawPointsPath.setLatLngs(rawPointsCoords);
                    rawPointsPath.addTo(map);
                    //
                    // // Add small markers for each raw point
                    // rawPointsData.points.forEach(point => {
                    //     L.circleMarker([point.latitude, point.longitude], {
                    //         radius: 3,
                    //         fillColor: '#9c27b0',
                    //         color: '#fff',
                    //         weight: 1,
                    //         opacity: 0.7,
                    //         fillOpacity: 0.7
                    //     }).addTo(map);
                    // });

                    // Extend bounds with raw points
                    const rawPointsBounds = L.latLngBounds(rawPointsCoords);
                    if (rawPointsBounds.isValid()) {
                        bounds.extend(rawPointsBounds);
                        hasValidCoords = true;
                    }
                }
            });

            // Fit map to bounds if we have valid coordinates
            if (hasValidCoords) {
                map.fitBounds(bounds, {
                    padding: [50, 50],
                    maxZoom: 16
                });
            }
        }

        // Handle clicks on timeline entries
        document.querySelector('.timeline-container').addEventListener('click', function (event) {
            document.querySelectorAll('.timeline-container .timeline-entry')
                .forEach(entry => entry.classList.remove('active'));
            const entry = event.target.closest('.timeline-entry');
            if (!entry) return;
                
            entry.classList.add('active');
            selectedPath.remove();
            const newBounds = L.latLngBounds();

            const lat = parseFloat(entry.dataset.lat);
            const lng = parseFloat(entry.dataset.lng);

            if (entry.dataset.path) {
                const pathData = JSON.parse(entry.dataset.path);
                const latlngs = pathData.map(coord => [coord.latitude, coord.longitude]);
                latlngs.forEach(latlng => {
                    newBounds.extend(latlng);
                });
                selectedPath.setLatLngs(latlngs);
                selectedPath.addTo(map);
            }
                
            if (!isNaN(lat) && !isNaN(lng)) {
                newBounds.extend([lat, lng]);
            }
                
            if (newBounds.isValid()) {
                map.flyToBounds(newBounds, {
                    padding: [50, 50],
                    maxZoom: 16
                });
            }
        });

        loadTimelineData(formattedDate);

        // Parse the initial date properly to ensure correct date picker initialization
        let dateToUse = new Date();
        if (initialDate) {
            // Parse the date from URL parameter (YYYY-MM-DD format)
            const [year, month, day] = initialDate.split('-').map(Number);
            // Note: month is 0-indexed in JavaScript Date
            dateToUse = new Date(year, month - 1, day);
        }

        // Initialize horizontal date picker
        new HorizontalDatePicker({
            container: document.getElementById('horizontal-date-picker-container'),
            selectedDate: dateToUse,
            autoSelectOnScroll: true, // Enable auto-select on scroll
            showNavButtons: false, // Show navigation buttons
            daysToShow: 21, // Show more days
            showMonthRow: true, // Enable month selection row
            showYearRow: true, // Enable year selection row
            yearsToShow: 5, // Show 5 years in the year row
            allowFutureDates: false, // Disable selection of future dates
            showTodayButton: true, // Show the Today button
            // No min/max date for infinite scrolling
            onDateSelect: (date, formattedDate) => {
                // Update URL
                updateUrlWithDate(formattedDate);

                // Load timeline data
                loadTimelineData(formattedDate);
            }
        });
    });
</script>
</body>
</html>
